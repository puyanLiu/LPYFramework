<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
    </head>
    <body>
    </body>
</html>

<script>
	var num1; //这个时候不进行内存分配
    var num3=9;//分配内存
    var num4=num3;//会不会分配


     //  这里到底分配还是不分配内存？？
     // 答案 --分配内存 彼此拥有独立的内存空间，互不影响
    console.log(num3)
    console.log(num4)

    num3=3333333;
    num4=4444444;
    console.log(num3)
    console.log(num4) //当更改数据，值不一样的本质是这里分配两个空间独立存储

    //字符串
    var str1; //这个时候不进行内存分配
    var str2 = '哈哈'; //分配内存
    var str3=str2; //问题，这里str3 会不会分配内存？？ 
//    答案：会
    console.log(str1)
    console.log(str2)
    console.log(str3)
    console.log(str2===str3) //比较的是指针指向的内存空间中存储的值

    str2 ='222222222'
    str3 ='333333333'
    console.log(str2)
    console.log(str3)	


    //    数组 ： 当定义一个新数组，
    // 内存会产生两篇区域，一个存储变量，一个存储数组 变量中保存的只是数组所在的地址
    var arr1=['哈哈1','哈哈2'];//分配内存
    //引用类型其实是指向同一个地址,也就是操纵的其实是同一个位置
    var arr2=arr1;   //问题：这里arr2会不会分配内存
    console.log(arr1[0]);
    console.log(arr2[0]); //一样

    //修改数组1
    arr2[0]='水浒传 西游记 三国演义 红楼梦';
    console.log(arr1[0]);
    console.log(arr2[0]);
    //一样 说明这里不分配内存，其实arr2变量中存的是地址，指向arr1内存
    
    
    //    系统都会在内存中生成两个区域：一个存储变量，一个用来存储函数
	//    而变量中存放的只是函数空间所在的地址（指针）
	//    由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。
	//由于函数名仅仅是指向函数的指针，
	//因此函数名与包含对象指针的其他变量没有什么不同。
	//换句话说，一个函数可能会有多个名字，例如：
	function sum(num1,num2)
	    {
	        return num1 + num2;
	    }
	console.log(sum(10,10)); //20

	var anotherSum = sum;

	 //内存是如何分配的？ 这里不会在内存生成新的空间，存储函数，而是生成一个变量，变量中保存的是同一个地址
	sum = null;//这里只是将sum变量中原来保存的是函数地址，然后赋值成null，这样做并不会影响到函数对象对应的内存空间
	console.log(anotherSum(10,10)); //20
	// console.log(sum(10,10)); 
	//    null的作用
    

	 function show(x) {
        console.log(typeof(x));    // undefined 值类型
        console.log(typeof(10));   // number 值类型
        console.log(typeof('abc')); // string 值类型
        console.log(typeof(true));  // Boolean 值类型
        console.log(typeof(function () { }));  //函数 引用类型
        console.log(typeof([1, 'a', true]));  //数组  引用类型
        console.log(typeof ({ a: 10, b: 20 }));  //object 或者json  引用类型
        console.log(typeof (null));  //null  引用类型
        console.log(typeof (new Number(10)));  //内置对象 引用类型
    }
    show();
//    其中上面的四种（undefined, number, string, boolean）属于值类型，不是对象。
//    函数、数组、对象、null、new Number(10)都是对象。他们都是引用类型。


    var test ={name:'wangshukui'};
    var test2=  test;
    console.log(test === test2);
    test.name='zhangsan';
    console.log(test2.name);



    var a = {"x": 1};
    var b = a;
    a.x = 2;
    console.log(b.x);
    //2
    /*解析*/
    /*将a赋值给b b中保存的只是地址，也就是a变量，b变量指向同一个对象*/
    /*修改a.x 同时也修改了b.x - 以为修改的都是同一块内存区域*/


    var a = {"x": 1};
    var b = a;
    a.x = 2;
    console.log(b.x);
    a = {"x":3};
    console.log(b.x);
    /*解析*/
    /*这里又定义了一个新的对象，重新分配内存空间，这个时候a变量中存储的是新地址，而b还是指向老对象*/
    /*所以这里b.x还是2*/

    var a = {"x": 1};
    var b = a;
    a.x = 2;
    console.log(b.x);
    a = {"x":3};
    console.log(b.x);
    a.x = 4;
    console.log(b.x);
    /*解析*/
    /*a b这个时候分别指向不同的对象，所以修改a不会影响b*/
    /*所以这里b.x还是2*/


    var a = {n:1};
    var b = a;
    a.x = a = {n:2};
    console.log(a);
    console.log(a.x); // undefined
    console.log(b.x); // {n:2}

    console.log('1111111');
    var a = {n:1};
    var b = a;
    a = {n:2};
    a.x = a;
    console.log(a); // {n: 2, x: {n: 2}}
    console.log(a.x); // {n: 2}
    console.log(b.x); // undefined

    

</script>