<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
    </head>
    <body>
    </body>
</html>

<script>
	
//    返回正被执行的 Function 对象，也就是所指定的 Function 对象的正文.
//     callee是arguments 的一个属性成员，它表示对函数对象本身的引用
//        arguments.callee.length可以获取形参参数


//callee用处1 用来判断实际参数跟行参是否一致
function calleeLengthDemo(arg1, arg2) {
	console.log('-------------------', arguments);
//    callee表示当前正在执行的函数对象，其实是函数的一个实例化
    console.log(arguments.callee.toString());
    if (arguments.length == arguments.callee.length) {
        window.console.log("验证形参和实参长度正确！");
        return;
    } else {
        console.log("实参长度：" + arguments.length);
        console.log("形参长度： " + arguments.callee.length);
    }
}
//当函数被执行的时候，生成一个实例
calleeLengthDemo(1);


 /*什么是递归
    一个方法，自己调用自己，用上一次调用得出的结果作为这次的参数*/
//callee用处2 调用自身 - 比如递归函数
// 优点:这样就让代码更加简练。又防止了全局变量的污染
//如下是一个递归算法 - 计算 1+2+3+4+...+n
var fn=(function(n){
    if(n>0) 
    	return n + arguments.callee(n-1);
    return 0;
})(10);
console.log('采用callee方式:'+fn)


// 传统方式的缺点:
// 1,破坏了,零重复法则,当一旦函数名称更改,需要更改多处
// 2,fn是一个全局变量,fn内部一般使用局部变量,而这里是一个全局变量,这是一个潜在的全局变量污染
var fn=function(n){
    if(n>0) return n+fn(n-1);
    return 0;
}
console.log('采用传统方式'+fn(10))
</script>